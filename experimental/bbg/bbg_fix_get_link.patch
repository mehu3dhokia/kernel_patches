diff --git a/Baseband-guard/baseband_guard.c b/Baseband-guard/baseband_guard.c
index 9668050..32a4416 100644
--- a/Baseband-guard/baseband_guard.c
+++ b/Baseband-guard/baseband_guard.c
@@ -216,7 +216,7 @@ static inline int is_protected_blkdev(struct dentry *dentry)
 {
     struct inode *inode;
 
-    if (!dentry)
+    if (IS_ERR_OR_NULL(dentry))
         return 0;
 
     inode = d_backing_inode(dentry);
@@ -232,23 +232,30 @@ static inline int is_protected_blkdev(struct dentry *dentry)
 
 	// there will handle all symlink, to avoid create an symlink -> /dev/block/by-name and modify
     if (unlikely(S_ISLNK(inode->i_mode) && inode->i_op->get_link)) { // fix /dev/block/by-name/xxx rename bypass
-		const char* symlink_target_link = inode->i_op->get_link(dentry, inode, NULL);
-		int result = 0;
-		struct path target_path;
-
-		if (IS_ERR_OR_NULL(symlink_target_link))
-        	return 0;
-		if (symlink_target_link[0] != '/') 
-			return 0;// because /dev/block/by-name's symlink's target always is absolute path, so we don't care relative path
-		
-		if (kern_path(symlink_target_link, LOOKUP_FOLLOW, &target_path) == 0) {
-        	struct inode *target_inode = d_backing_inode(target_path.dentry);
-        	if (target_inode && S_ISBLK(target_inode->i_mode)) {
-            	result = 1;
-        	}
-        	path_put(&target_path);
+        DEFINE_DELAYED_CALL(done);
+        const char* symlink_target_link = inode->i_op->get_link(dentry, inode, &done);
+        int result = 0;
+        struct path target_path;
+
+        if (IS_ERR_OR_NULL(symlink_target_link)) {
+            result = 0;
+            goto out_do_and_clear_cb;
+	}
+        if (symlink_target_link[0] != '/') {
+	    result = 0; // because /dev/block/by-name's symlink's target always is absolute path, so we don't care relative path
+            goto out_do_and_clear_cb;
+	}
+        if (kern_path(symlink_target_link, LOOKUP_FOLLOW, &target_path) == 0) {
+            struct inode *target_inode = d_backing_inode(target_path.dentry);
+            if (target_inode && S_ISBLK(target_inode->i_mode)) {
+                result = 1;
+            }
+            path_put(&target_path);
     	}
-		return result;
+out_do_and_clear_cb:
+        do_delayed_call(&done);
+	clear_delayed_call(&done);
+        return result;
     }
 
     return 0;
